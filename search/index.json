[{"categories":["linux"],"contents":" I/O多路复用的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作\n IO多路复用 select、poll 和 epoll 都是 Linux 提供的 IO 多路复用方式。\n与多进程和多线程相比，IO多路复用的最大优点是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。\nSelect 首先分析一下select函数\nint select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout); 参数说明 int nfds 的值为所有文件描述符中的最大值加1。\nfd_set *readfds , fd_set *writefds , fd_set *exceptfds 可以理解成一个集合，其中的元素是文件描述符。fd_set类型变量每一位代表了一个描述符。我们也可以认为它只是一个由很多二进制位构成的数组。中间的三个参数指定我们要让内核测试读、写和异常条件的文件描述符集合。如果对某一个的条件不感兴趣，就可以把它设为NULL。\nstruct timeval *timeout 指定了select等待文件描述符做好准备的时间。\n返回值 返回fd_set集合中就绪的读、写，或出错的文件描述符数量，返回0表示超时，返回-1表示出错；\nSelect运行机制 select的机制中提供一种fd_set的数据结构，实际上是一个long类型的数组，每一个数组元素都能与一打开的文件描述符建立联系，当调用select时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select的进程哪一文件描述符变为了就绪状态。\nSelect的问题  我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是哪个元素，我们只能无差别遍历集合中所有的元素，这样的话时间复杂度为O(n)，而且如果同时监视的元素越多，这个时间越长。 为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)。  Poll poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。也就是说，poll解决了上述的问题2，但是没有解决性能开销较大的问题\npoll函数原型如下\nint poll(struct pollfd *fds, nfds_t nfds, int timeout); struct pollfd { int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */ }; poll改变了文件描述符集合的存储方式，使用了pollfd结构而不是select的fd_set结构，使得poll支持的文件描述符集合远大于select的1024。\n参数说明 struct pollfd *fds fds是一个struct pollfd类型的数组，用于存放需要检测其状态的socket描述符，一个pollfd结构体表示一个被监视的文件描述符其中。\nnfds_t nfds 记录数组fds中描述符的总数量\nint timeout类似select的struct timeval，为超时时间。\n返回值 类似于select函数，返回fds集合中就绪的读、写，或出错的文件描述符数量，返回0表示超时，返回-1表示出错；\nEpoll epoll在Linux2.6内核正式提出，是基于事件驱动的I/O方式，相对于select来说，epoll没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。\nlinux提供的epoll相关的函数如下：\nint epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);   epoll_create 函数创建一个epoll描述符，参数size表明要监听的描述符数量。调用成功时返回一个epoll描述符，失败时返回-1。\n注意：使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。\n  epoll_ctl 函数注册要监听的事件类型。四个参数解释如下：\n epfd 表示epoll描述符。 op表示fd操作类型，有如下3种：  EPOLL_CTL_ADD添加新的fd到epfd中 EPOLL_CTL_MOD修改已存在的fd的监听事件 EPOLL_CTL_DEL从epfd中删除一个fd   fd 是要监听的描述符。 event 表示要监听的事件。  epoll_event 结构体定义如下：\nstruct epoll_event { __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; events可以是以下几个宏的集合：\nEPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）； EPOLLOUT：表示对应的文件描述符可以写； EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； EPOLLERR：表示对应的文件描述符发生错误； EPOLLHUP：表示对应的文件描述符被挂断； EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。 EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n  epoll_wait 函数等待事件的就绪，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。\n epfd 是epoll描述符 events 表示从内核得到的就绪事件集合 maxevents events的大小 timeout 表示等待的超时事件    Epoll实现 #define PORT 8888 #define MAX_EVENTS 10  int creat_listen_socket() { int listen_socket; if ((listen_socket = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { perror(\u0026#34;socket() error\u0026#34;); return -1; } struct sockaddr_in my_addr; memset(\u0026amp;my_addr, 0, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_port = htons(PORT); my_addr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(listen_socket, (struct sockaddr *)\u0026amp;my_addr, sizeof(my_addr)) \u0026lt; 0) { perror(\u0026#34;bind\u0026#34;); return -1; } if (listen(listen_socket, 5) \u0026lt; 0) { perror(\u0026#34;listen\u0026#34;); } return listen_socket; } int main() { struct epoll_event ev, events[MAX_EVENTS]; int listen_sock, conn_sock, nfds, epollfd; /* Code to set up listening socket, \u0026#39;listen_sock\u0026#39;, (socket(), bind(), listen()) omitted */ listen_sock = creat_listen_socket(); epollfd = epoll_create1(0); if (epollfd == -1) { perror(\u0026#34;epoll_create1\u0026#34;); exit(EXIT_FAILURE); } ev.events = EPOLLIN; ev.data.fd = listen_sock; if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, \u0026amp;ev) == -1) { perror(\u0026#34;epoll_ctl: listen_sock\u0026#34;); exit(EXIT_FAILURE); } for (;;) { nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1); if (nfds == -1) { perror(\u0026#34;epoll_wait\u0026#34;); exit(EXIT_FAILURE); } struct sockaddr_in client_addr; unsigned int addrlen = sizeof(client_addr); for (int n = 0; n \u0026lt; nfds; ++n) { if (events[n].data.fd == listen_sock) { conn_sock = accept(listen_sock, (struct sockaddr *) \u0026amp;client_addr, \u0026amp;addrlen); if (conn_sock == -1) { perror(\u0026#34;accept\u0026#34;); exit(EXIT_FAILURE); } int imode = 1; ioctl(conn_sock, FIONBIO, \u0026amp;imode); //将新连接设置成非阻塞状态  ev.events = EPOLLIN | EPOLLET; //将新连接加入epoll监听  ev.data.fd = conn_sock; if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, \u0026amp;ev) == -1) { perror(\u0026#34;epoll_ctl: conn_sock\u0026#34;); exit(EXIT_FAILURE); } } else { do_use_fd(events[n].data.fd); } } } return 0; } 总结     select poll Epoll     操作方式 遍历 遍历 回调   底层实现 数组 链表 哈希表   IO效率 每次调用都进行线性遍历，时间复杂度为O(n) 每次调用都进行线性遍历，时间复杂度为O(n) 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1)   最大连接数 1024（x86）或2048（x64） 无上限 无上限   fd拷贝 每次调用select，都需要把fd集合从用户态拷贝到内核态 每次调用poll，都需要把fd集合从用户态拷贝到内核态 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝     既然select，poll，epoll都是I/O多路复用的具体的实现，之所以现在同时存在，其实他们也是不同历史时期的产物\n select出现是1984年在BSD里面实现的。 14年之后也就是1997年才实现了poll，其实拖那么久也不是效率问题， 而是那个时代的硬件实在太弱，一台服务器处理1千多个链接简直就是神一样的存在了，select很长段时间已经满足需求。 2002, 大神 Davide Libenzi 实现了epoll。  ","permalink":"https://prohub.pub/posts/linux%E4%B8%ADio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8Fselectpollepoll/","tags":["linux"],"title":"linux中IO多路复用的三种方式select、poll、epoll"},{"categories":["linux"],"contents":"简介 在程序进行工作时，有可能会发生阻塞。所谓阻塞，顾名思义，就是进程或是线程执行到这些函数时必须等待某个事件的发生，如果事件没有发生，进程或线程就被阻塞，函数不能立即返回，例如connect、 accept、recv这样的函数。而使用select就可以完成非阻塞方式工作的程序，而非阻塞方式就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高，它能够监视我们需要监视的文件描述符的变化情况——读写或是异常。\n头文件 #include \u0026lt;sys/select.h\u0026gt;\n函数原型 int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);\n函数说明 select()可以用来等待文件描述符的状态的改变。传递给select()的参数会告诉内核:\n 需要关注的文件描述符的。 需要对一个文件描述符读或者写，还是关注这个文件描述符是否发生异常。 需要等待的时间。  在select()返回时，内核则会告诉我们以下信息：\n 对于我们的要求已经做好准备的描述符的个数。 对于三种条件（读，写，异常）那些描述符已经做好准备。  参数说明   nfds:\n其值为所有文件描述符中的最大值加1。\n  fd_set:\n可以理解成一个集合，其中的元素是文件描述符。fd_set类型变量每一位代表了一个描述符。我们也可以认为它只是一个由很多二进制位构成的数组。\n系统提供了4个宏对描述符集进行操作：\nvoid FD_SET(int fd, fd_set *set);//添加文件描述符到fd_set集合中 void FD_CLR(int fd, fd_set *set); //从fd_set集合中删除文件描述符 int FD_ISSET(int fd, fd_set *set);//判断文件描述符是否在fd_set中 void FD_ZERO(fd_set *set);//清空fd_set集合   readfds：\nfd_set *readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select()就会返回一个大于0的值，表示有文件可读；如果没有可读的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select()返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。\n  writefds:\nfd_set *writefds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，如果这个集合中有一个文件可写，select()就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select(返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。\n  exceptfds:\nfd_set *errorfds同上面两个参数，用来监视文件错误异常文件。\n  timeout:\nstruct timeval* timeout指定了select()等待文件描述符做好准备的时间。\ntimeval结构体定义如下\nstruct timeval { long tv_sec; /*秒 */ long tv_usec; /*微秒 */ } 有三种情况:\n  timeout == NULL\n等待无限长的时间。等待可以被一个信号中断。当有一个描述符做好准备或者是捕获到一个信号时函数会返回。如果捕获到一个信号， select()函数将返回 -1,并将变量 errno设为 EINTR。\n  timeout-\u0026gt;tv_sec == 0 \u0026amp;\u0026amp; timeout-\u0026gt;tv_usec == 0\n不等待，直接返回。加入描述符集的描述符都会被测试，并且返回满足要求的描述符的个数。这种方法通过轮询，无阻塞地获得了多个文件描述符状态。\n  timeout-\u0026gt;tv_sec != 0 || timeout-\u0026gt;tv_usec != 0\n等待指定的时间，当有描述符符合条件或者超过超时时间的话，函数返回。对于这种情况，等待也会被信号所中断。\n    返回值 成功则返回集合中已经就绪的描述符的数量，超时则返回为0，发生错误则返回-1并设置errno。\n","permalink":"https://prohub.pub/posts/linux-select%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","tags":["linux"],"title":"linux select函数用法详解"},{"categories":["linux"],"contents":"说明 前段时间买了一个阿里云的学生服务器，之前一直用作学习linux的工具。最近写markdown文档的时候发现自己缺一个图床，于是我就想到了在自己的服务器上搭建一个图床。通过搜索，我找到了一个能在服务器上方便搭建图床的工具——chevereto。\nchevereto是一个功能非常强大的图床，而chevereto的安装也非常简单，并且支持中文，可以上传本地图片或通过url上传图片。效果如下\n官网： https://chevereto.com/\n安装 环境要求：\n Apache/Nginx PHP 5.5+ MySQL 5.0+    搭建web环境\n可以使用lnmp来一键搭建web环境，然而安装lnmp的时间可能会很长，我们在它执行完毕之前，不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。为了避免这种情况，我们可以使用screen。\nGNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。\n在登录服务器后，运行\nscreen -S lnmp 如果提示screen: command not found 命令不存在可以执行：yum install screen 或 apt-get install screen安装\n然后安装lnmp\nlnmp一键包安装地址：https://lnmp.org/install.html\nwget http://soft.vpser.net/lnmp/lnmp1.5.tar.gz -cO lnmp1.5.tar.gz \u0026amp;\u0026amp; tar zxf lnmp1.5.tar.gz \u0026amp;\u0026amp; cd lnmp1.5 \u0026amp;\u0026amp; ./install.sh lnmp   添加网站\nlnmp vhost add 按步骤填写，可参考：https://lnmp.org/faq/lnmp-vhost-add-howto.html\n  下载chevereto\nchevereto下载地址：https://github.com/Chevereto/Chevereto-Free\n切换到你的网站的目录\ncd /home/wwwroot/你的网站名 执行命令\nwget https://github.com/Chevereto/Chevereto-Free/archive/1.1.3.tar.gz 然后解压文件\ntar zfvx 1.1.3.tar.gz 将解压的文件复制到网站根目录,进入解压好目录，执行\ncp -r * .. 然后赋予目录相应的权限\nchmod -R 777 ./* 最后进入网站的配置文件\ncd /usr/local/nginx/conf/vhost/你的网站名.conf 在server中加入以下代码\nlocation / { try_files $uri $uri/ /index.php?$query_string; } 然后重启Nginx\n/etc/init.d/nginx restart 或者\nlnmp restart 然后就可以打开网站按要求进行配置了。\n**注意：**打开网站后可能会出现Chevereto can’t create the app/settings.php file. You must manually create this file的错误，这时在app目录新建settings.php文件并给予可写入权限即可。\n  ","permalink":"https://prohub.pub/posts/%E7%94%A8chevereto%E6%9D%A5%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/","tags":["图床"],"title":"用chevereto来搭建自己的图床"},{"categories":["hexo"],"contents":"前言 Hexo默认的主题是landscape,但是爱折腾的我显然并不满足于默认主题(真香)，找来找去也就发现了这个便于折腾的主题————NexT。\n注：在 Hexo 中有两份主要的配置文件，其名称都是_config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项 。\n为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。\n安装NexT 下载主题 在终端窗口下，定位到 Hexo 站点目录下。运行命令git clone https://github.com/theme-next/hexo-theme-next themes/next来安装主题。\n启用主题 与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。\n到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。\n验证主题 首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：\nINFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000 ,检查站点是否正确运行。\n现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定。\n主题设定 选择 Scheme Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持四种 Scheme。具体的样式可以参考 https://github.com/theme-next/hexo-theme-next\nScheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。\n设置语言 编辑 站点配置文件， 将 language 设置成中文。配置如下\nlanguage: zh-CN 设置作者昵称 编辑 站点配置文件， 设置 author 为你的昵称。\n站点描述 编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:)\n设置头像 编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是：\n   地址 值     完整的互联网 URI http://example.com/avatar.png   站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录 若不存在）配置为：avatar: /uploads/avatar.png或者放置在 source/images/ 目录下配置为：avatar: /images/avatar.png    设置阅读全文 Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，但这会使你的首页篇幅过于冗长。\n要解决这个问题，打开 主题配置文件，找到以下代码：\nauto_excerpt: enable: false length: 150 将false改为true，length为预览文章的长度。\n添加gitalk评论功能 注册新应用 在GitHub上注册新应用，链接：https://github.com/settings/applications/new\n参数说明： Application name： # 应用名称，随意 Homepage URL： # 网站URL，如 https://xxxxxxxx.github.io Application description # 描述，随意 Authorization callback URL：# 网站URL，如 https://xxxxxxxx.github.io\n点击注册后，页面跳转到应用界面，其中Client ID和Client Secret在后面的配置中需要用到，到时复制粘贴即可\n修改主题配置文件 在主题配置文件中搜索gitalk字段：\ngitalk: enable: true githubID: github帐号 repo: 仓库名称 ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 distractionFreeMode: true 添加「标签」页面 在你的站点目录下，运行命令：\nhexo new page tags 添加分类页面过程类似\n如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false。\n设置代码高亮主题 NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties。\n更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题。\n侧边栏社交链接 找到social字段，将注释去掉并修改即可。\n开启打赏功能 只需要主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。\nreward: enable: true #comment: Donate comment here wechatpay: /images/wechatpay.jpg alipay: /images/alipay.jpg #bitcoin: /images/bitcoin.png 友情链接 编辑 主题配置文件,修改links字段。\n设置「背景动画」  定位到你的NexT文件夹中，运行命令git clonegit clone https://github.com/theme-next/theme-next-three source/lib/three 修改three_waves,canvas_lines,canvas_sphere任意一种为true  设置页面透明度 由于NexT主题默认的背景是不透明的，所以我们刚刚设置的背景动画会被文章挡住，所以我们要修改页面的透明度，主要依靠修改CSS样式来实现\n文章部分 文件位置 ~Hexo根目录/themes/next/source/css/_schemes/Gemini/index.styl\n// Post \u0026amp; Comments blocks. .post-block { padding: $content-desktop-padding; background: rgba(255,255,255,0.7); box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; } 阅读全文按钮 文件位置 ~Hexo根目录/themes/next/source/css/_variables/Pisces.styl\n// Button $btn-default-radius = 2px $btn-default-bg = rgba(255,255,255,0.5) $btn-default-color = $text-color $btn-default-border-color = $text-color $btn-default-hover-color = white $btn-default-hover-bg = $black-deep 分页部分 文件位置 ~Hexo根目录/themes/next/source/css/_schemes/Gemini/index.styl\n// Pagination. .pagination { .prev, .next, .page-number { margin-bottom: initial; top: initial; } margin: sboffset 0 0; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius; padding: 10px 0 10px; } 评论区部分 文件位置 ~Hexo根目录/themes/next/source/css/_schemes/Gemini/index.styl\n// Comments blocks. .comments { padding: $content-desktop-padding; margin: initial; margin-top: sboffset; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius; } 侧边菜单界面 文件位置 ~Hexo根目录/themes/next/source/css/_schemes/Pisces/_layout.styl\n.header-inner { position: absolute; top: 0; overflow: hidden; padding: 0; width: $sidebar-desktop; background: rgba(255,255,255,0.7); box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +desktop-large() { .container \u0026amp; { width: $sidebar-desktop; } } +tablet() { position: relative; width: auto; border-radius: initial; } +mobile() { position: relative; width: auto; border-radius: initial; } } 个人资料界面 文件位置 ~Hexo根目录/themes/next/source/css/_schemes/Pisces/_sidebar.styl\n.sidebar-inner { //padding: 20px 10px 0; box-sizing: border-box; width: $sidebar-desktop; color: $text-color; background: rgba(255,255,255,0.7); box-shadow: $box-shadow; border-radius: $border-radius; if (hexo-config('motion.enable') and hexo-config('motion.transition.sidebar')) { opacity: 0; } \u0026amp;.affix { position: fixed; top: $sidebar-offset; } 添加字数统计和阅读时间 定位到你的博客下，运行以下命令：\n$ npm install hexo-symbols-count-time --save 打开 站点配置文件 ,在最后加入以下内容：\nsymbols_count_time: symbols: true time: true total_symbols: true total_time: true 打开 主题配置文件 ，搜索symbols_count_time并修改成以下内容：\nsymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 显示当前浏览进度 打开主题配置文件，修改以下内容：\n# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 在右上角或者左上角实现fork me on github 首先在这里或这里挑选你喜欢的样式并复制代码，然后将其中的链接改为你自己的github地址，最后打开themes/next/layout/_layout.swig将改好的代码粘贴在\u0026lt;div class=\u0026quot;headband\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;下面。\n添加点击爱心效果 创建js文件 在/themes/next/source/js/src下新建文件 clicklove.js,然后将以下代码拷贝进去：\n!function(e,t,a){function n(){c(\u0026quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\u0026quot;),o(),r()}function r(){for(var e=0;e\u0026lt;d.length;e++)d[e].alpha\u0026lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\u0026quot;left:\u0026quot;+d[e].x+\u0026quot;px;top:\u0026quot;+d[e].y+\u0026quot;px;opacity:\u0026quot;+d[e].alpha+\u0026quot;;transform:scale(\u0026quot;+d[e].scale+\u0026quot;,\u0026quot;+d[e].scale+\u0026quot;) rotate(45deg);background:\u0026quot;+d[e].color+\u0026quot;;z-index:99999\u0026quot;);requestAnimationFrame(r)}function o(){var t=\u0026quot;function\u0026quot;==typeof e.onclick\u0026amp;\u0026amp;e.onclick;e.onclick=function(e){t\u0026amp;\u0026amp;t(),i(e)}}function i(e){var a=t.createElement(\u0026quot;div\u0026quot;);a.className=\u0026quot;heart\u0026quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\u0026quot;style\u0026quot;);a.type=\u0026quot;text/css\u0026quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\u0026quot;head\u0026quot;)[0].appendChild(a)}function s(){return\u0026quot;rgb(\u0026quot;+~~(255*Math.random())+\u0026quot;,\u0026quot;+~~(255*Math.random())+\u0026quot;,\u0026quot;+~~(255*Math.random())+\u0026quot;)\u0026quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 修改_layout.swig 在\\themes\\next\\layout\\_layout.swig文件末尾添加：\n\u0026lt;!-- 页面点击小红心 --\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/js/src/clicklove.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 文章尾部添加版权信息 打开 主题配置文件 ,搜索creative_commons，将post修改为true。\n修改文章底部的那个带#号的标签 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=\u0026quot;tag\u0026quot;\u0026gt;#，将 # 换成\u0026lt;i class=\u0026quot;fa fa-tag\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\n添加顶部加载条 安装插件 定位到/themes/next，运行以下命令：\ngit clone https://github.com/theme-next/theme-next-pace source/lib/pace 修改主题配置文件 打开 主题配置文件 搜索pace，改为true,然后修改pace-theme为你喜欢的样式\n添加搜索服务 添加百度/谷歌/本地 自定义站点内容搜索\n 在站点的根目录下执行以下命令：  $ npm install hexo-generator-searchdb --save 编辑 站点配置文件 ，新增以下内容到任意位置：  search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件 ，启用本地搜索功能：  # Local search local_search: enable: true 添加分享服务  定位到/themes/next,运行以下命令：  git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 编辑 主题配置文件  needmoreshare2: enable: true postbottom: enable: true float: enable: true 添加在线聊天DaoVoice 注册 首先需要注册一个 DaoVoice，点击注册\n注册成功后，进入后台控制台，进入到 应用设置--\u0026gt;安装到网站 页面，可以得到一个 app_id。\n设置 打开 themes/next/layout/_partials/head.swig 文件中添加如下代码，位置随意：\n{% if theme.daovoice %} \u0026lt;script\u0026gt; (function(i,s,o,g,r,a,m){i[\u0026#34;DaoVoiceObject\u0026#34;]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=\u0026#34;utf-8\u0026#34;;m.parentNode.insertBefore(a,m)})(window,document,\u0026#34;script\u0026#34;,(\u0026#39;https:\u0026#39; == document.location.protocol ? \u0026#39;https:\u0026#39; : \u0026#39;http:\u0026#39;) + \u0026#34;//widget.daovoice.io/widget/0f81ff2f.js\u0026#34;,\u0026#34;daovoice\u0026#34;) daovoice(\u0026#39;init\u0026#39;, { app_id: \u0026#34;{{theme.daovoice_app_id}}\u0026#34; }); daovoice(\u0026#39;update\u0026#39;); \u0026lt;/script\u0026gt; {% endif %} 打开 主题配置文件 ，添加以下代码：\n# Online contact daovoice: true daovoice_app_id: 这里输入前面获取的app_id 添加网站运行时间 打开 \\themes\\next\\layout\\_partial\\footer.ejs 文件下添加以下代码：\n\u0026lt;span id=\u0026quot;timeDate\u0026quot;\u0026gt;载入天数...\u0026lt;/span\u0026gt;\u0026lt;span id=\u0026quot;times\u0026quot;\u0026gt;载入时分秒...\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; var now = new Date(); function createtime() { var grt= new Date(\u0026quot;12/04/2018 00:00:00\u0026quot;);//在此处修改你的建站时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = \u0026quot;0\u0026quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = \u0026quot;0\u0026quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = \u0026quot;0\u0026quot; + snum;} document.getElementById(\u0026quot;timeDate\u0026quot;).innerHTML = \u0026quot;本博客已萌萌哒运行 \u0026quot;+dnum+\u0026quot; 天 \u0026quot;; document.getElementById(\u0026quot;times\u0026quot;).innerHTML = hnum + \u0026quot; 小时 \u0026quot; + mnum + \u0026quot; 分 \u0026quot; + snum + \u0026quot; 秒\u0026quot;; } setInterval(\u0026quot;createtime()\u0026quot;,250); \u0026lt;/script\u0026gt; ","permalink":"https://prohub.pub/posts/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/","tags":["hexo"],"title":"Hexo的next主题优化以及插件配置"},{"categories":["hexo"],"contents":"正文 针对博客已经搭建并发布过文章的。\n  在你的博客仓库创建一个分支hexo(名称随意)；\n  设置hexo为默认分支；\n  将博客仓库clone至本地，将之前的Hexo文件夹中的_config.yml，themes/，source，scffolds/，package.json，.gitignore复制到你克隆下来的仓库文件夹，即Username.github.io；(Username是你自己的用户名);\n这里说一下为什么只需要拷贝6个，而不需要全部:\n  _config.yml站点的配置文件，需要拷贝\n  themes/主题文件夹，需要拷贝\n  source博客文章的md文件，需要拷贝\n  scaffolds/文章的模板，需要拷贝\n  package.json安装包的名称，需要拷贝\n  .gitignore限定在push时哪些文件可以忽略，需要拷贝\n  .git/主题和站点都有，标志这是一个git项目，不需要拷贝\n  node_modules/是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝\n  public是hexo g生成的静态网页，不需要拷贝\n  .deploy_git同上，hexo g也会生成，不需要拷贝\n  db.json文件，不需要拷贝\n其实不需要拷贝的文件正是.gitignore中所忽略的\n    themes/你使用的主题文件夹中的.git/删除，否则无法将主题文件夹push;\n  cd 到 Username.github.io，执行npm install,npm install hexo-deployer-git;\n  执行git add .，git commit -m \u0026quot;\u0026quot;，git push origin hexo来提交Hexo网站源文件;\n  执行hexo g -d生成静态网页部署到github上。\n这样，Username.github.io仓库就有master分支保存静态网页，hexo分支保存源文件。\n  修改 在本地对博客修改后\n 执行git add .，git commit -m \u0026quot;\u0026quot;，git push origin hexo来提交Hexo网站源文件。 执行hexo g -d生成静态网页部署到github上。  恢复 换电脑改博客\n  安装git;\n  安装Nodejs和npm;\n  使用git clone将仓库拷贝至本地;\n  在文件夹内执行命令npm install hexo-cli -g、npm install、npm install hexo-deployer-git。\n   参考\n原始链接：https://blog.itswincer.com/posts/7efd2818/\n文章作者：WincerChan\n ","permalink":"https://prohub.pub/posts/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/","tags":["hexo"],"title":"Hexo博客备份"},{"categories":["hexo"],"contents":"前言 本文采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处！\n环境准备   Node.js 下载，并安装；\n  Git 下载，并安装；\n  安装Hexo，在命令行运行以下命令：\n npm install -g hexo-cli    在命令行依次运行以下命令（folder为你的博客文件夹名）：\nhexo init \u0026lt;folder\u0026gt; cd \u0026lt;folder\u0026gt; npm install   注意：\n  与hexo相关命令均在站点目录下；\n  站点配置文件：站点目录下的_config.yml；\n  主题配置文件：站点目录下的/themes/主题名/_config.yml；\n  启动服务。在命令行中输入以下命令：\nhexo server  或\nhexo s\n 打开浏览器，访问 http://localhost:4000/\n至此，你的Hexo博客已经搭建在本地。\n  部署至GithubPages   创建Github账号\n  创建仓库，仓库名为：你的Github账号名称.github.io\n  将本地搭建的Hexo博客推送到GithubPages，方法如下：\n  安装hexo-deployer-git插件，运行以下命令： npm install hexo-deployer-git --save\n  添加SSH key。\n  创建一个 SSH key 。在命令行输入以下命令， 然后一路回车即可。 ssh-keygen -t rsa -C \u0026quot;github邮箱地址\u0026quot;\n  复制生成的密钥文件内容（id_rsa.pub），粘贴到github的New SSH Key即可。\n  测试是否添加成功,依次输入以下命令：\nssh -T git@github.com yes     修改博客目录下的_config.yml，修改末尾:\ndeploy: type: git repo: git@github.com:你的Github账号名称/你的Github账号名称.github.io.git branch: master   部署到GithubPages，依次输入以下命令：\nhexo g hexo d   等待几十秒，打开：https://你的Github账号名称.github.io。\n至此，你的Hexo博客已经搭建在GithubPages，并可以通过域名 https://你的Github账号名称.github.io 访问。\n    ","permalink":"https://prohub.pub/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","tags":["hexo"],"title":"Hexo博客搭建教程"},{"categories":null,"contents":"","permalink":"https://prohub.pub/search/","tags":null,"title":"Search"}]